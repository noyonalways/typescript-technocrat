<h1 align='center'>Object Oriented TypeScript</h1>

## Topics

1. Introduction of Object Oriented Programming
2. Class and object
3. Inheritance in OOP.
4. Type guard using typeof & in
5. Type guard using instance of
6. Access modifiers
7. Getter and setter
8. Statics in OOP
9. Polymorphism
10. Abstraction in OOP
11. Encapsulation in OOP

## Table of Contents

- [Introduction of Object Oriented Programming](#introduction-of-object-oriented-programming)
  - [What is OOP?](#what-is-oop)
  - [What is Paradigm?](#what-is-paradigm)
  - [Procedural Programming](#procedural-programming)
  - [Functional Programming](#functional-programming)
  - [Declarative Programming](#declarative-programming)
  - [Object Oriented Programming](#object-oriented-programming)
  - [Event Driven Programming](#event-driven-programming)
  - [Building Blocks of OOP](#building-blocks-of-oop)
- [Class And Object](#class-and-object)
  - [Normal way](#normal-way)
  - [Using Parameter properties](#using-parameter-properties)
- [Inheritance In OOP](#inheritance-in-oop)
  - [Person Class](#person-class)
  - [Student Class](#student-class)
  - [Teacher Class](#teacher-class)
- [Type Guard Using Typeof \& In](#type-guard-using-typeof--in)
  - [typeof guard](#typeof-guard)
  - [in guard](#in-guard)
- [Type Guard Using Instance Of](#type-guard-using-instance-of)
  - [Normal way](#normal-way-1)
  - [Handle in smart way](#handle-in-smart-way)
- [Access Modifiers](#access-modifiers)
  - [modifiers:](#modifiers)
  - [Private:](#private)
  - [Protected:](#protected)
- [Getter And Setter](#getter-and-setter)
  - [Example-1](#example-1)
  - [Example-2](#example-2)
- [Statics In OOP](#statics-in-oop)
  - [Explanation:](#explanation)
  - [In short:](#in-short)
  - [Different memory:](#different-memory)
  - [Single memory](#single-memory)
  - [Static in methods](#static-in-methods)
- [Polymorphism](#polymorphism)
  - [Example-1](#example-1-1)
  - [Example-2](#example-2-1)
- [Abstraction In OOP](#abstraction-in-oop)
  - [Using the interface](#using-the-interface)
  - [Using the abstract](#using-the-abstract)
- [Encapsulation In OOP](#encapsulation-in-oop)
  - [Example-1](#example-1-2)
  - [Example-2](#example-2-2)

# Introduction of Object Oriented Programming

### What is OOP?

A programming paradigm that organizes and models software.

### What is Paradigm?

The style used to write and organize code.

### Procedural Programming

Procedural Programming is a coding approach that organizes a computer program into a set of structured procedures or functions. These procedures consist of a series of well-defined steps or instructions that are executed sequentially. However, it may lack the flexibility and reusability of more advanced programming paradigms.

### Functional Programming

Functional Programming is like using a set of building blocks that are like mathematical functions. This helps in making your code easier to understand and less likely to have bugs.

### Declarative Programming

Declarative Programming is an approach to writing computer programs that focuses on describing the desired outcomes or result, rather than explicitly specifying the step-by-step instructions to achieve that outcome. In declarative programming, and the underlying system or framework figures out how to achieve.

### Object Oriented Programming

Object-Oriented Programming (OOP) is a programming paradigm that organizes code around objects, which are instances of classes defining data and behavior. In OOP, software is designed by modeling real-world entities as objects, each having attributes (data) and methods (functions) that operate on the data.

### Event Driven Programming

Event-driven Programming is a programming paradigm that resolves around responding to events or signals generated by the system or user interactions. In event-driven programming, software is designed to wait for and react to events, such as user clicks, keyboard inputs, or system notifications

### Building Blocks of OOP

- Inheritance
- Polymorphism
- Abstraction
- Encapsulation

# Class And Object

### Normal way

```tsx
// 3-1: Class And Object

// oop - class

class Animal {
  public name: string;
  public species: string;
  public sound: string;

  constructor(name: string, species: string, sound: string) {
    this.name = name;
    this.species = species;
    this.sound = sound;
  }

  makeSound() {
    console.log(`The ${this.name} sound is ${this.sound}`);
  }
}

const cat = new Animal("Tom", "cat", "Meow Meow");
const dog = new Animal("Husky", "cat", "Gheow Ghew");

cat.makeSound();
```

### Using Parameter properties

```tsx
class Animal {
  // public name: string;
  // public species: string;
  // public sound: string;

  // using parameter properties

  constructor(
    public name: string,
    public species: string,
    public sound: string
  ) {
    // this.name = name;
    // this.species = species;
    // this.sound = sound;
  }

  makeSound() {
    console.log(`The ${this.name} sound is ${this.sound}`);
  }
}

const cat = new Animal("Tom", "cat", "Meow Meow");
const dog = new Animal("Husky", "cat", "Gheow Ghew");

cat.makeSound();
```

# Inheritance In OOP

### Person Class

```tsx
// 3-2: Inheritance In OOP

class Person {
  constructor(
    public name: string,
    public age: number,
    public address: string
  ) {}

  getSleep(numberOfHours: number) {
    console.log(`${this.name} will sleep for ${numberOfHours}`);
  }
}
```

### Student Class

```tsx
// Student
class Student extends Person {
  constructor(name: string, age: number, address: string) {
    super(name, age, address);
  }
}

const student1 = new Student("Mr. Student", 21, "Bangladesh");
student1.getSleep(6);
```

### Teacher Class

```tsx
// Teacher
class Teacher extends Person {
  constructor(
    name: string,
    age: number,
    address: string,
    public designation: string
  ) {
    super(name, age, address);
  }

  takeClass(numberOfClass: number) {
    console.log(`${this.name} will take class ${numberOfClass}`);
  }
}

const teacher1 = new Teacher("Mr. Teacher", 21, "Bangladesh", "Professor");
teacher1.takeClass(3);
```

# Type Guard Using Typeof & In

### typeof guard

```tsx
// 3-3: Type Guard Using Typeof & In

// typeof --> type guard
type Alphanumeric = number | string;

const add = (param1: Alphanumeric, param2: Alphanumeric): Alphanumeric => {
  if (typeof param1 === "number" && typeof param2 === "number") {
    return param1 + param2;
  } else {
    return param1.toString() + param2.toString();
  }
};

const result1 = add(33, 17);
const result2 = add("33", 17);
console.log(result1);
console.log(result2);
```

### in guard

```tsx
// in guard
type NormalUser = {
  name: string;
};

type AdminUser = {
  name: string;
  role: "admin";
};

const getUser = (user: NormalUser | AdminUser) => {
  if ("role" in user) {
    console.log(`My name is ${user.name} and my role is ${user.role}`);
  } else {
    console.log(`My name is ${user.name}`);
  }
};

const normalUser: NormalUser = {
  name: "Mr. Normal Bhai",
};

const adminUser: AdminUser = {
  name: "Mr. Admin Bhai",
  role: "admin",
};

getUser(normalUser);
getUser(adminUser);
```

# Type Guard Using Instance Of

```tsx
// 3-4: Type Guard Using Instance Of

// animal class
class Animal {
  name: string;
  species: string;

  constructor(name: string, species: string) {
    this.name = name;
    this.species = species;
  }

  makeSound() {
    console.log(`I am making sound`);
  }
}

// dog class
class Dog extends Animal {
  constructor(name: string, species: string) {
    super(name, species);
  }

  makeBark() {
    console.log(`I am barking`);
  }
}

// cat class
class Cat extends Animal {
  constructor(name: string, species: string) {
    super(name, species);
  }

  makeMeow() {
    console.log(`I am meowing`);
  }
}
```

### Normal way

```tsx
const getAnimal = (animal: Animal) => {
  if (animal instanceof Dog) {
    animal.makeBark();
  } else if (animal instanceof Cat) {
    animal.makeMeow();
  } else {
    animal.makeSound();
  }
};

const dog = new Dog("Dog Bhai", "dog");
const cat = new Cat("Cat Bhai", "cat");

getAnimal(cat);
```

### Handle in smart way

```tsx
// If we handle in smart way we can use functions

const isDog = (animal: Animal): animal is Dog => {
  return animal instanceof Dog;
};

const isCat = (animal: Animal): animal is Cat => {
  return animal instanceof Cat;
};

const getAnimal = (animal: Animal) => {
  if (isDog(animal)) {
    animal.makeBark();
  } else if (isCat(animal)) {
    animal.makeMeow();
  } else {
    animal.makeSound();
  }
};

const dog = new Dog("Dog Bhai", "dog");
const cat = new Cat("Cat Bhai", "cat");

getAnimal(cat);
```

# Access Modifiers

### modifiers:

1. **public**: This is the default access modifier in TypeScript. It means that the property or method is accessible from anywhere, both within the class and outside of it.
2. **private**: When a member is marked as private, it can only be accessed within the class it is declared in. Subclasses cannot access these members.
3. **protected**: Similar to private, but members marked as protected can also be accessed within subclasses. They are not accessible from outside the class hierarchy.

### Private:

```tsx
// 3-5: Access Modifiers
class BankAccount {
  public id: number;
  public name: string;
  private balance: number;

  constructor(id: number, name: string, balance: number) {
    this.id = id;
    this.name = name;
    this.balance = balance;
  }
}

const poorMan = new BankAccount(111, "Mr. Poor", 20);
poorMan.balance = 0;
// Property balance is private and only accessible within class BankAccount .
console.log(poorMan);
```

### Protected:

```tsx
// 3-5: Access Modifiers
class BankAccount {
  public id: number;
  public name: string;
  protected _balance: number;

  constructor(id: number, name: string, balance: number) {
    this.id = id;
    this.name = name;
    this._balance = balance;
  }

  addDeposit(amount: number) {
    this._balance = this._balance + amount;
    return;
  }

  getBalance() {
    return this._balance;
  }
}

class StudentAccount extends BankAccount {
  public get balance() {
    return this._balance;
  }
}

const poorMan = new BankAccount(111, "Mr. Poor", 20);
const studentMan = new StudentAccount(222, "Mr. Student", 50);

console.log(studentMan.balance);

/**
 * Access modifiers
 * - public: will expose the property or method to instance and child class
 * - private: property will only accessible in the class
 * - protected: property or method will expose the property to his child class
 */
```

# Getter And Setter

In TypeScript, getters and setters are a way to control access to an object's properties.

- **Getter**: A getter is a method that gets the value of a property. It allows you to retrieve the value of a property as if it were a regular property access, but behind the scenes, you can execute custom logic. You define a getter using the **`get`** keyword followed by the property name.
- **Setter**: A setter is a method that sets the value of a property. It allows you to perform validation or execute custom logic before setting the value of a property. You define a setter using the **`set`** keyword followed by the property name.

### Example-1

```tsx
class Circle {
  private _radius: number;

  constructor(radius: number) {
    this._radius = radius;
  }

  get radius(): number {
    return this._radius;
  }

  set radius(value: number) {
    if (value >= 0) {
      this._radius = value;
    } else {
      throw new Error("Radius cannot be negative.");
    }
  }
}

const circle = new Circle(5);
console.log(circle.radius); // Output: 5

circle.radius = 10;
console.log(circle.radius); // Output: 10

circle.radius = -5; // Throws an error: "Radius cannot be negative."
```

In this example, `radius` is a property of the `Circle` class. We define a getter and a setter for `radius`. The getter returns the value of `_radius`, and the setter validates the value before setting it to `_radius`.

### Example-2

Access modifiers can be used in conjunction with getters and setters in TypeScript. You can apply access modifiers (**`public`**, **`private`**, or **`protected`**) to both the getter and setter methods just like you would for regular properties or methods.

```tsx
// 3-6: Getter And Setter

class BankAccount {
  public id: number;
  public name: string;
  protected _balance: number;

  constructor(id: number, name: string, balance: number) {
    this.id = id;
    this.name = name;
    this._balance = balance;
  }

  addDeposit(amount: number) {
    this._balance = this._balance + amount;
    return;
  }

  // getter
  public get balance() {
    return this._balance;
  }

  // setter
  public set deposit(amount: number) {
    this._balance = this._balance + amount;
  }
}

const poorMan = new BankAccount(111, "Mr. Poor", 25);
poorMan.deposit = 20;

const balance = poorMan.balance;
console.log(balance);
```

# Statics In OOP

### Explanation:

In TypeScript, just like in many object-oriented programming (OOP) languages, including JavaScript, static members are properties or methods that belong to the class itself rather than to instances of the class. This means they are shared among all instances of the class and can be accessed directly through the class name without needing an instance.

Here's a brief explanation of statics:

1. **Static Properties**: These are properties that belong to the class itself, not to instances of the class. They are declared using the `static` keyword.
2. **Static Methods**: Similarly, static methods are methods that belong to the class itself. They can be called directly on the class without the need to instantiate an object of the class.

Here's an example to illustrate:

```tsx
class MathUtility {
  // Static property
  static PI: number = 3.14159;

  // Static method
  static calculateArea(radius: number): number {
    return this.PI * radius * radius;
  }
}

console.log(MathUtility.PI); // Accessing static property directly
console.log(MathUtility.calculateArea(5)); // Calling static method directly
```

In this example, `PI` is a static property of the `MathUtility` class, and `calculateArea()` is a static method. You can access the static property and call the static method directly on the class without creating an instance of `MathUtility`.

Static members are useful for functionality that does not depend on a particular instance of the class, such as utility methods or constants. They are also often used to implement singleton patterns or factory methods.

### In short:

Sure, in TypeScript, statics in OOP refer to properties or methods that belong to the class itself rather than to instances of the class. They are accessed directly through the class name, not through an object instance. Statics are useful for functionality that is common across all instances of a class or doesn't require instance-specific data.

### Different memory:

```tsx
// 3-7 Statics In OOP

class Counter {
  count: number = 0;

  increment() {
    return (this.count = this.count + 1);
  }

  decrement() {
    return (this.count = this.count - 1);
  }
}

const instance1 = new Counter();
console.log(instance1.increment()); // 1 -> different memory

const instance2 = new Counter();
console.log(instance2.increment());
```

### Single memory

```tsx
// 3-7 Statics In OOP

class Counter {
  static count: number = 0;

  increment() {
    return (Counter.count = Counter.count + 1);
  }

  decrement() {
    return (Counter.count = Counter.count - 1);
  }
}

const instance1 = new Counter();
console.log(instance1.increment()); // same memory
console.log(instance1.increment()); // same memory
console.log(instance1.increment()); // same memory

const instance2 = new Counter();
console.log(instance2.increment()); // same memory
```

### Static in methods

```tsx
// 3-7 Statics In OOP

class Counter {
  static count: number = 0;

  static increment() {
    return (Counter.count = Counter.count + 1);
  }

  static decrement() {
    return (Counter.count = Counter.count - 1);
  }
}

console.log(Counter.increment()); // same memory
console.log(Counter.increment()); // same memory
console.log(Counter.increment()); // same memory
```

# Polymorphism

Polymorphism in TypeScript, as in other object-oriented programming languages, refers to the ability of objects of different classes to be treated as objects of a common superclass. This allows for more generic and flexible code, as methods can be invoked on objects of different types without needing to know the specific type at compile time.

### Example-1

```tsx
// ploymorphism
class Person {
  getSleep() {
    console.log(`I am sleeping for 8 hours per day`);
  }
}

class Student extends Person {
  getSleep() {
    console.log(`I am sleeping for 7 hours per day`);
  }
}

class Developer extends Person {
  getSleep() {
    console.log(`I am sleeping for 6 hours per day`);
  }
}

const getSleepingHours = (parm: Person) => {
  parm.getSleep();
};

const person1 = new Person();
const person2 = new Student();
const person3 = new Developer();

getSleepingHours(person1);
getSleepingHours(person2);
getSleepingHours(person3);
```

### Example-2

```tsx
class Shape {
  getArea(): number {
    return 0;
  }
}

class Circle extends Shape {
  radius: number;

  constructor(radius: number) {
    super();
    this.radius = radius;
  }

  getArea(): number {
    return Math.PI * this.radius * this.radius;
  }
}

class Rectangle extends Shape {
  height: number;
  width: number;

  constructor(height: number, width: number) {
    super();
    this.height = height;
    this.width = width;
  }

  getArea(): number {
    return this.height * this.width;
  }
}

const getShapeArea = (param: Shape) => {
  console.log(param.getArea());
};

const shape1 = new Shape();
const shape2 = new Circle(10);
const shape3 = new Rectangle(10, 20);

getShapeArea(shape1);
getShapeArea(shape2);
getShapeArea(shape3);
```

# Abstraction In OOP

Abstraction in object-oriented programming (OOP), including TypeScript, refers to the concept of hiding the internal details and complexities of how a particular feature is implemented, while exposing a simplified interface for users to interact with.

In TypeScript, abstraction is typically achieved through the use of abstract classes and methods. An abstract class is a class that cannot be instantiated on its own and may contain one or more abstract methods, which are methods without a concrete implementation. Instead, the responsibility of providing an implementation for these abstract methods lies with the subclasses that extend the abstract class.

Here's a simple example to illustrate abstraction in TypeScript:

```tsx
abstract class Shape {
  abstract calculateArea(): number;
}

class Circle extends Shape {
  constructor(private radius: number) {
    super();
  }

  calculateArea(): number {
    return Math.PI * this.radius ** 2;
  }
}

class Rectangle extends Shape {
  constructor(private width: number, private height: number) {
    super();
  }

  calculateArea(): number {
    return this.width * this.height;
  }
}

const circle = new Circle(5);
console.log(circle.calculateArea()); // Output: Approximately 78.54

const rectangle = new Rectangle(4, 6);
console.log(rectangle.calculateArea()); // Output: 24
```

In this example, `Shape` is an abstract class that defines the abstract method `calculateArea()`. Concrete subclasses `Circle` and `Rectangle` provide their own implementations of `calculateArea()`. Users of these classes can interact with them through the abstract interface defined by `Shape`, without needing to know the internal details of how each shape calculates its area.

Abstraction helps in managing complexity, promoting code reuse, and providing a clear separation of concerns in your codebase. It allows you to focus on what needs to be done (the interface), rather than how it's done (the implementation details).

### Using the interface

```tsx
// using the interface
interface Vehicle1 {
  startEngine(): void;
  stopEngine(): void;
  move(): void;
}

class Car1 implements Vehicle1 {
  startEngine(): void {
    console.log(`I am starting the car engine`);
  }

  stopEngine(): void {
    console.log(`I am stopping the car engine`);
  }

  move(): void {
    console.log(`I am moving the car`);
  }

  test(): void {
    console.log(`I am testing the car`);
  }
}

const toyota = new Car1();
toyota.startEngine();
```

### Using the abstract

```tsx
// using abstract
abstract class Car2 {
  abstract startEngine(): void;
  abstract stopEngine(): void;
  abstract move(): void;
  abstract test(): void;
}

class Honda extends Car2 {
  startEngine(): void {
    console.log(`I am starting the honda engine`);
  }
  stopEngine(): void {
    console.log(`I am stopping the honda engine`);
  }
  move(): void {
    console.log(`I am moving the honda`);
  }
  test(): void {
    console.log(`I am testing the honda`);
  }
}

const honda = new Honda();
honda.startEngine();

// const honda = new Car2();
// Cannot create an instance of an abstract class
```

# Encapsulation In OOP

- **Encapsulation** is one of the fundamental principles of object-oriented programming.
- It involves bundling the data (properties) and methods (functions) that operate on the data into a single unit called a **class**.
- The internal state of an object (its properties) is kept private within the class, and access to it is controlled through **accessors** (getter and setter methods).
- **Benefits** of encapsulation include:
  - **Data Hiding**: Encapsulation hides the internal state of an object, preventing direct access and manipulation by external code.
  - **Abstraction**: Encapsulation allows objects to present a simplified interface to the outside world, hiding complex implementation details.
  - **Modularity**: Encapsulation promotes modularity by organizing code into self-contained units (classes), making it easier to maintain and understand.
- In TypeScript, you can achieve encapsulation by using access modifiers (`public`, `private`, and `protected`) to control the visibility of properties and methods within a class.
- Example in TypeScript:

### Example-1

```tsx
class Car {
  private _speed: number; // Private property

  constructor(speed: number) {
    this._speed = speed;
  }

  // Public method to access and modify the speed property
  get speed(): number {
    return this._speed;
  }

  set speed(value: number) {
    if (value >= 0) {
      this._speed = value;
    } else {
      throw new Error("Speed must be a non-negative number.");
    }
  }
}

const myCar = new Car(60);
console.log(myCar.speed); // Output: 60
myCar.speed = 80; // Set speed using setter method
console.log(myCar.speed); // Output: 80
```

In this example, the `speed` property is encapsulated within the `Car` class, and access to it is controlled through the getter and setter methods. This prevents direct access to the `speed` property from outside the class, ensuring data integrity and encapsulation.

### Example-2

```tsx
// 3-10: Encapsulation In OOP
class BankAccount1 {
  public id: number;
  public name: string;
  private _balance: number;

  constructor(id: number, name: string, balance: number) {
    this.id = id;
    this.name = name;
    this._balance = balance;
  }

  addDeposit(amount: number) {
    this._balance = this._balance + amount;
    return;
  }

  private getBalance() {
    return this._balance;
  }
}

class StudentAccount1 extends BankAccount1 {
  public get balance() {
    return this._balance;
    // Property '_balance' is private and only accessible within class 'BankAccount1'
  }
}

const poorMan1 = new BankAccount1(111, "Mr. Poor", 20);
poorMan1.getBalance();
// property 'getBalance' is private and only accessible within class 'BankAccount1'

const studentMan1 = new StudentAccount1(222, "Mr. Student", 50);

console.log(studentMan1.balance);
```
